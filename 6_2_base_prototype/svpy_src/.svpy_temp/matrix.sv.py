import svpy
from svpy import *
svpy.writefile = open("../lab6_2_provided/design_source/matrix.sv", 'w')
import svmath
import utils
svwrite("/* matrix.sv\n")
dump_queue()
svwrite(" *  - Author: Kobe Duda\n")
dump_queue()
svwrite(" *  - Descrption: Contains a set of matrix operation-related modules\n")
dump_queue()
svwrite(" *\n")
dump_queue()
svwrite(" *  - All matrices are stored in row-major order\n")
dump_queue()
svwrite(" *\n")
dump_queue()
svwrite(" *\n")
dump_queue()
svwrite(" *\n")
dump_queue()
svwrite("*/\n")
dump_queue()
svwrite("\n")
dump_queue()
from svmath import *
svwrite("module matrix_multiplier\n")
dump_queue()
svwrite("#(\n")
dump_queue()
svwrite("    parameter DATA_WIDTH = 16,\n")
dump_queue()
svwrite("    parameter DECIMAL_BITS = 5\n")
dump_queue()
svwrite(")\n")
dump_queue()
svwrite("(\n")
dump_queue()
svwrite("    input logic [DATA_WIDTH - 1:0] a [2][2],\n")
dump_queue()
svwrite("    input logic [DATA_WIDTH - 1:0] b [2][2],\n")
dump_queue()
svwrite("    \n")
dump_queue()
svwrite("    output logic [DATA_WIDTH - 1:0] out [2][2]\n")
dump_queue()
svwrite(");\n")
dump_queue()
svwrite("\n")
dump_queue()
begin_comb()
svwrite("       // Compute products\n")
dump_queue()
svwrite("       logic [(DATA_WIDTH * 2) - 1:0] p0000;\n")
dump_queue()
svwrite("       logic [(DATA_WIDTH * 2) - 1:0] p0110;\n")
dump_queue()
svwrite("       logic [(DATA_WIDTH * 2) - 1:0] p0001;\n")
dump_queue()
svwrite("       logic [(DATA_WIDTH * 2) - 1:0] p0111;\n")
dump_queue()
svwrite("       logic [(DATA_WIDTH * 2) - 1:0] p1000;\n")
dump_queue()
svwrite("       logic [(DATA_WIDTH * 2) - 1:0] p1110;\n")
dump_queue()
svwrite("       logic [(DATA_WIDTH * 2) - 1:0] p1001;\n")
dump_queue()
svwrite("       logic [(DATA_WIDTH * 2) - 1:0] p1111;\n")
dump_queue()
svwrite("\n")
dump_queue()
svwrite("       p0000 = a[0][0] * b[0][0];\n")
dump_queue()
svwrite("       p0110 = a[0][1] * b[1][0];\n")
dump_queue()
svwrite("       p0001 = a[0][0] * b[0][1];\n")
dump_queue()
svwrite("       p0111 = a[0][1] * b[1][1];\n")
dump_queue()
svwrite("       p1000 = a[1][0] * b[0][0];\n")
dump_queue()
svwrite("       p1110 = a[1][1] * b[1][0];\n")
dump_queue()
svwrite("       p1001 = a[1][0] * b[0][1];\n")
dump_queue()
svwrite("       p1111 = a[1][1] * b[1][1];\n")
dump_queue()
svwrite("\n")
dump_queue()
svwrite("       // Compute output using products (products are bit sliced because fixed point multiplication is icky)\n")
dump_queue()
svwrite("       out[0][0] = p0000[DECIMAL_BITS +: DATA_WIDTH] + p0110[DECIMAL_BITS +: DATA_WIDTH];\n")
dump_queue()
svwrite("       out[0][1] = p0001[DECIMAL_BITS +: DATA_WIDTH] + p0111[DECIMAL_BITS +: DATA_WIDTH];\n")
dump_queue()
svwrite("       out[1][0] = p1000[DECIMAL_BITS +: DATA_WIDTH] + p1110[DECIMAL_BITS +: DATA_WIDTH];\n")
dump_queue()
svwrite("       out[1][1] = p1001[DECIMAL_BITS +: DATA_WIDTH] + p1111[DECIMAL_BITS +: DATA_WIDTH];\n")
dump_queue()
end_comb()
svwrite("endmodule\n")
dump_queue()
svwrite("\n")
dump_queue()
svwrite("module vec_mat_multiplier\n")
dump_queue()
svwrite("#(\n")
dump_queue()
svwrite("    parameter DATA_WIDTH = 16,\n")
dump_queue()
svwrite("    parameter DECIMAL_BITS = 5\n")
dump_queue()
svwrite(")\n")
dump_queue()
svwrite("(\n")
dump_queue()
svwrite("    input logic [DATA_WIDTH - 1:0] mat [2][2],\n")
dump_queue()
svwrite("    input logic [DATA_WIDTH - 1:0] vec [2],\n")
dump_queue()
svwrite("    \n")
dump_queue()
svwrite("    output logic [DATA_WIDTH - 1:0] out [2]\n")
dump_queue()
svwrite(");\n")
dump_queue()
svwrite("\n")
dump_queue()
begin_comb()
svwrite("       // Compute products\n")
dump_queue()
svwrite("       logic [(DATA_WIDTH * 2) - 1:0] p00_0;\n")
dump_queue()
svwrite("       logic [(DATA_WIDTH * 2) - 1:0] p01_1;\n")
dump_queue()
svwrite("       logic [(DATA_WIDTH * 2) - 1:0] p10_0;\n")
dump_queue()
svwrite("       logic [(DATA_WIDTH * 2) - 1:0] p11_1;\n")
dump_queue()
svwrite("\n")
dump_queue()
svwrite("       p00_0 = mat[0][0] * vec[0];\n")
dump_queue()
svwrite("       p01_1 = mat[0][1] * vec[1];\n")
dump_queue()
svwrite("       p10_0 = mat[1][0] * vec[0];\n")
dump_queue()
svwrite("       p11_1 = mat[1][1] * vec[1];\n")
dump_queue()
svwrite("\n")
dump_queue()
svwrite("       // Compute output using products (products are bit sliced because fixed point multiplication is icky)\n")
dump_queue()
svwrite("       out[0] = p00_0[DECIMAL_BITS +: DATA_WIDTH] + p01_1[DECIMAL_BITS +: DATA_WIDTH];\n")
dump_queue()
svwrite("       out[1] = p10_0[DECIMAL_BITS +: DATA_WIDTH] + p11_1[DECIMAL_BITS +: DATA_WIDTH];\n")
dump_queue()
end_comb()
svwrite("endmodule")
dump_queue()
svpy.writefile.close()