import svpy
from svpy import *
svpy.writefile = open("../lab6_2_provided/design_source/box_box_resolver.sv", 'w')
import svmath
import utils
svwrite("// box_box_resolver.sv\n")
dump_queue()
svwrite("//  - Resolves contacts between two OBBs\n")
dump_queue()
svwrite("//  - Takes in the data of the OBBs and the contact data\n")
dump_queue()
svwrite("//  - Outputs the new state of the OBBs\n")
dump_queue()
svwrite("\n")
dump_queue()
RESTITUTION = 0.5
svwrite("\n")
dump_queue()
from svmath import *
from svmath import ExpressionVec2
from structs import OBB, JOBB, Contact, Impulse
svwrite("\n")
dump_queue()
obb1 = OBB("obb1")
obb2 = OBB("obb2")
svwrite("\n")
dump_queue()
rotational_impulse1 = Fixed(4, 7, "rotational_impulse1")
rotational_impulse2 = Fixed(4, 7, "rotational_impulse2")
svwrite("module box_box_resolver (\n")
dump_queue()
svwrite("    ")
svpy.inline_state = True
svwrite(Contact.declare("input"))
svpy.inline_state = False
svwrite(",\n")
dump_queue()
svwrite("\n")
dump_queue()
svwrite("    ")
svpy.inline_state = True
svwrite(obb1.declare("input"))
svpy.inline_state = False
svwrite(",\n")
dump_queue()
svwrite("    ")
svpy.inline_state = True
svwrite(obb2.declare("input"))
svpy.inline_state = False
svwrite(",\n")
dump_queue()
svwrite("\n")
dump_queue()
svwrite("    ")
svpy.inline_state = True
svwrite(Impulse.declare("output"))
svpy.inline_state = False
svwrite(",\n")
dump_queue()
svwrite("    ")
svpy.inline_state = True
svwrite(rotational_impulse1.declare("output"))
svpy.inline_state = False
svwrite(",\n")
dump_queue()
svwrite("    ")
svpy.inline_state = True
svwrite(rotational_impulse2.declare("output"))
svpy.inline_state = False
svwrite("\n")
dump_queue()
svwrite(");\n")
dump_queue()
svwrite("\n")
dump_queue()
svwrite("// Get vectors from centers of OBBS to contact point\n")
dump_queue()
r1 = Contact.location - obb1.pos
r2 = Contact.location - obb2.pos
svwrite("\n")
dump_queue()
svwrite("/* Steps:\n")
dump_queue()
svwrite("    1. Get relative velocity\n")
dump_queue()
svwrite("    2. Use to calculate separating velocity\n")
dump_queue()
svwrite("*/\n")
dump_queue()
vs = Fixed(6, 26, "vs")
vs.declare()
totalIMass = Fixed(2, 8, "totalIMass")
totalIMass.declare()
svwrite("\n")
dump_queue()
svwrite("// Invert total inverse mass because we gotta divide by it\n")
dump_queue()
inv_totalIMass = inverse(totalIMass)
svwrite("\n")
dump_queue()
begin_comb()
svwrite("\n")
dump_queue()
svwrite("// Get vector omega x r1 and omega x r2\n")
dump_queue()
vw1 = ExpressionVec2(-r1[1], r1[0]) * obb1.omega
vw2 = ExpressionVec2(-r2[1], r2[0]) * obb2.omega
svwrite("\n")
dump_queue()
print("vw:", vw1.x.integer_bits, vw1.y.precision)
print("obb velocity:", obb1.vel.x.integer_bits, obb1.vel.x.precision)
svwrite("\n")
dump_queue()
svwrite("// Get relative velocity\n")
dump_queue()
v_rel = (obb1.vel - obb2.vel) + (vw1 - vw2)
print("v_rel:", v_rel.x.integer_bits, v_rel.x.precision)
print("Normal:", Contact.normal.integer_bits, Contact.normal.precision)
svwrite("\n")
dump_queue()
svwrite("// Get separating velocity\n")
dump_queue()
vs.assign(v_rel.Dot(Contact.normal))
svwrite("\n")
dump_queue()
svwrite("// Get total inverse mass/inertia\n")
dump_queue()
r1Cross = r1.Cross(Contact.normal)
r2Cross = r2.Cross(Contact.normal)
svwrite("\n")
dump_queue()
totalIMass.assign((obb1.inv_mass + obb2.inv_mass) + (r1Cross * r1Cross * obb1.inv_inertia) + (r2Cross * r2Cross * obb2.inv_inertia))
svwrite("\n")
dump_queue()
svwrite("\n")
dump_queue()
svwrite("// Calculate impulse vector\n")
dump_queue()
impulse_magnitude = (vs * (-(1 + RESTITUTION)) * inv_totalIMass)
Impulse.impulse.assign(Contact.normal * impulse_magnitude)
svwrite("\n")
dump_queue()
svwrite("//$ Impulse.impulse.assign(Contact.normal * (vs * (-(1 + RESTITUTION) / 2)))       # /2 is to divide by the inverse masses, which are assumed to be 1\n")
dump_queue()
svwrite("\n")
dump_queue()
svwrite("// Calculate rotational impulse for both boxes\n")
dump_queue()
rotational_impulse1.assign(impulse_magnitude * r1Cross * obb1.inv_inertia)
rotational_impulse2.assign(-(impulse_magnitude * r2Cross * obb2.inv_inertia))
svwrite("//$ rotational_impulse1.assign(0)\n")
dump_queue()
svwrite("//$ rotational_impulse2.assign(0)\n")
dump_queue()
svwrite("\n")
dump_queue()
svwrite("\n")
dump_queue()
svwrite("//// Getting nudge vector\n")
dump_queue()
double_nudge = Contact.normal * Contact.penetration
svwrite("")
svpy.inline_state = True
svwrite(Impulse.nudge.x)
svpy.inline_state = False
svwrite(" = ")
svpy.inline_state = True
svwrite(double_nudge.x)
svpy.inline_state = False
svwrite(" >>> 1;\n")
dump_queue()
svwrite("")
svpy.inline_state = True
svwrite(Impulse.nudge.y)
svpy.inline_state = False
svwrite(" = ")
svpy.inline_state = True
svwrite(double_nudge.y)
svpy.inline_state = False
svwrite(" >>> 1;\n")
dump_queue()
svwrite("\n")
dump_queue()
end_comb()
svwrite("\n")
dump_queue()
svwrite("endmodule")
dump_queue()
svpy.writefile.close()