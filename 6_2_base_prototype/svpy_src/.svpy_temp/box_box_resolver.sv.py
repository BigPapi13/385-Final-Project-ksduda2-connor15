import svpy
from svpy import *
svpy.writefile = open("../lab6_2_provided/design_source/box_box_resolver.sv", 'w')
import svmath
import utils
svwrite("// box_box_resolver.sv\n")
dump_queue()
svwrite("//  - Resolves contacts between two OBBs\n")
dump_queue()
svwrite("//  - Takes in the data of the OBBs and the contact data\n")
dump_queue()
svwrite("//  - Outputs the new state of the OBBs\n")
dump_queue()
svwrite("\n")
dump_queue()
RESTITUTION = 0.5
svwrite("\n")
dump_queue()
from svmath import *
from svmath import ExpressionVec2
from structs import OBB, JOBB, Contact, Impulse
svwrite("\n")
dump_queue()
obb1 = OBB("obb1")
obb2 = OBB("obb2")
svwrite("\n")
dump_queue()
impulse1 = Impulse("impulse1")
impulse2 = Impulse("impulse2")
svwrite("module box_box_resolver (\n")
dump_queue()
svwrite("    ")
svpy.inline_state = True
svwrite(Contact.declare("input"))
svpy.inline_state = False
svwrite(",\n")
dump_queue()
svwrite("\n")
dump_queue()
svwrite("    ")
svpy.inline_state = True
svwrite(obb1.declare("input"))
svpy.inline_state = False
svwrite(",\n")
dump_queue()
svwrite("    ")
svpy.inline_state = True
svwrite(obb2.declare("input"))
svpy.inline_state = False
svwrite(",\n")
dump_queue()
svwrite("\n")
dump_queue()
svwrite("    ")
svpy.inline_state = True
svwrite(impulse1.declare("output"))
svpy.inline_state = False
svwrite(",\n")
dump_queue()
svwrite("    ")
svpy.inline_state = True
svwrite(impulse2.declare("output"))
svpy.inline_state = False
svwrite(",\n")
dump_queue()
svwrite("    output logic ignore_impulse\n")
dump_queue()
svwrite(");\n")
dump_queue()
svwrite("\n")
dump_queue()
signed_obb1_inv_I = Fixed(2, 23, "signed_obb1_inv_I");
signed_obb2_inv_I = Fixed(2, 23, "signed_obb2_inv_I");
signed_obb1_inv_I.declare()
signed_obb2_inv_I.declare()
svwrite("assign signed_obb1_inv_I = {1'b0, ")
svpy.inline_state = True
svwrite(obb1.inv_inertia)
svpy.inline_state = False
svwrite("};\n")
dump_queue()
svwrite("assign signed_obb2_inv_I = {1'b0, ")
svpy.inline_state = True
svwrite(obb2.inv_inertia)
svpy.inline_state = False
svwrite("};\n")
dump_queue()
svwrite("\n")
dump_queue()
npos = Vec2(8, 14, "npos")
npos.assign(Contact.location + impulse1.nudge)
npos.declare()
svwrite("\n")
dump_queue()
svwrite("// Get vectors from centers of OBBS to contact point\n")
dump_queue()
r1 = Vec2(8, 14, "r1")
r2 = Vec2(8, 14, "r2")
r1.declare()
r2.declare()
r1.assign(npos - obb1.pos)
r2.assign(npos - obb2.pos)
print(r1.x.integer_bits, r1.x.precision)
svwrite("\n")
dump_queue()
svwrite("/* Steps:\n")
dump_queue()
svwrite("    1. Get relative velocity\n")
dump_queue()
svwrite("    2. Use to calculate separating velocity\n")
dump_queue()
svwrite("*/\n")
dump_queue()
vs = Fixed(5, 19, "vs")
vs.declare()
totalIMass = Fixed(2, 8, "totalIMass")
totalIMass.declare()
svwrite("\n")
dump_queue()
vw1 = Vec2(5, 19, "vw1")
vw2 = Vec2(5, 19, "vw2")
vw1.declare()
vw2.declare()
svwrite("\n")
dump_queue()
svwrite("// Invert total inverse mass because we gotta divide by it\n")
dump_queue()
inv_totalIMass = inverse(totalIMass)
svwrite("\n")
dump_queue()
double_nudge = Vec2(8, 16, "double_nudge")
double_nudge.declare()
svwrite("\n")
dump_queue()
r1Cross = Fixed(8, 14, "r1Cross")
r2Cross = Fixed(8, 14, "r2Cross")
r1Cross.declare()
r2Cross.declare()
r1CrossInertia = Fixed(8, 24, "r1CrossInertia")
r2CrossInertia = Fixed(8, 24, "r2CrossInertia")
r1CrossInertia.declare()
r2CrossInertia.declare()
svwrite("\n")
dump_queue()
v_rel = Vec2(5, 19, "v_rel")
v_rel.declare()
impulse_magnitude = Fixed(5, 19, "impulse_magnitude")
impulse_magnitude.declare()
svwrite("\n")
dump_queue()
begin_comb()
svwrite("\n")
dump_queue()
svwrite("// Get vector omega x r1 and omega x r2\n")
dump_queue()
svwrite("//$ vw1.assign(ExpressionVec2(-r1[1].unrestrained_mul(obb1.omega), r1[0].unrestrained_mul(obb1.omega)))\n")
dump_queue()
svwrite("//$ vw2.assign(ExpressionVec2(-r2[1].unrestrained_mul(obb2.omega), r2[0].unrestrained_mul(obb2.omega)))\n")
dump_queue()
svwrite("\n")
dump_queue()
print(vw1.x.integer_bits, vw1.x.precision)
svwrite("\n")
dump_queue()
svwrite("// Get relative velocity\n")
dump_queue()
v_rel.assign((obb1.vel - obb2.vel))
svwrite("\n")
dump_queue()
svwrite("// Get separating velocity\n")
dump_queue()
vs.assign(v_rel.Dot(Contact.normal))
svwrite("\n")
dump_queue()
svwrite("// Get total inverse mass/inertia\n")
dump_queue()
r1Cross.assign(r1.Cross(Contact.normal))
r2Cross.assign(r2.Cross(Contact.normal))
r1CrossInertia.assign(r1Cross.unrestrained_mul(signed_obb1_inv_I))
r2CrossInertia.assign(r2Cross.unrestrained_mul(signed_obb2_inv_I))
print(r1CrossInertia.integer_bits, r1CrossInertia.precision)
svwrite("\n")
dump_queue()
totalIMass.assign((obb1.inv_mass + obb2.inv_mass) + (r1Cross * r1CrossInertia) + (r2Cross * r2CrossInertia))
svwrite("\n")
dump_queue()
svwrite("// Calculate impulse vector\n")
dump_queue()
impulse_magnitude.assign(vs * (-(1 + RESTITUTION)) * inv_totalIMass)
impulse1.impulse.assign(Contact.normal * impulse_magnitude)
impulse2.impulse.assign(-impulse1.impulse)
svwrite("\n")
dump_queue()
svwrite("// Calculate rotational impulse for both boxes\n")
dump_queue()
impulse1.rotational_impulse.assign(impulse_magnitude * r1CrossInertia)
impulse2.rotational_impulse.assign(-(impulse_magnitude * r2CrossInertia))
svwrite("\n")
dump_queue()
svwrite("//// Getting nudge vector\n")
dump_queue()
double_nudge.assign(Contact.normal * Contact.penetration)
svwrite("")
svpy.inline_state = True
svwrite(impulse1.nudge.x)
svpy.inline_state = False
svwrite(" = ")
svpy.inline_state = True
svwrite(double_nudge.x)
svpy.inline_state = False
svwrite(" >>> 1;\n")
dump_queue()
svwrite("")
svpy.inline_state = True
svwrite(impulse1.nudge.y)
svpy.inline_state = False
svwrite(" = ")
svpy.inline_state = True
svwrite(double_nudge.y)
svpy.inline_state = False
svwrite(" >>> 1;\n")
dump_queue()
impulse2.nudge.assign(-impulse1.nudge)
svwrite("\n")
dump_queue()
end_comb()
svwrite("\n")
dump_queue()
svwrite("// If separating velocity is positive, don't apply the impulse\n")
dump_queue()
svwrite("assign ignore_impulse = ~vs[23];\n")
dump_queue()
svwrite("\n")
dump_queue()
svwrite("endmodule")
dump_queue()
svpy.writefile.close()