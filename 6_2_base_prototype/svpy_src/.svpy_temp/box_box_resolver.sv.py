import svpy
from svpy import *
svpy.writefile = open("../lab6_2_provided/design_source/box_box_resolver.sv", 'w')
import svmath
import utils
svwrite("// box_box_resolver.sv\n")
dump_queue()
svwrite("//  - Resolves contacts between two OBBs\n")
dump_queue()
svwrite("//  - Takes in the data of the OBBs and the contact data\n")
dump_queue()
svwrite("//  - Outputs the new state of the OBBs\n")
dump_queue()
svwrite("\n")
dump_queue()
RESTITUTION = 0.5
svwrite("\n")
dump_queue()
from svmath import *
from svmath import ExpressionVec2
from structs import OBB, JOBB, Contact, Impulse
svwrite("\n")
dump_queue()
obb1 = OBB("obb1")
obb2 = OBB("obb2")
svwrite("\n")
dump_queue()
impulse1 = Impulse("impulse1")
impulse2 = Impulse("impulse2")
svwrite("module box_box_resolver (\n")
dump_queue()
svwrite("    ")
svpy.inline_state = True
svwrite(Contact.declare("input"))
svpy.inline_state = False
svwrite(",\n")
dump_queue()
svwrite("\n")
dump_queue()
svwrite("    ")
svpy.inline_state = True
svwrite(obb1.declare("input"))
svpy.inline_state = False
svwrite(",\n")
dump_queue()
svwrite("    ")
svpy.inline_state = True
svwrite(obb2.declare("input"))
svpy.inline_state = False
svwrite(",\n")
dump_queue()
svwrite("\n")
dump_queue()
svwrite("    ")
svpy.inline_state = True
svwrite(impulse1.declare("output"))
svpy.inline_state = False
svwrite(",\n")
dump_queue()
svwrite("    ")
svpy.inline_state = True
svwrite(impulse2.declare("output"))
svpy.inline_state = False
svwrite(",\n")
dump_queue()
svwrite("    output logic ignore_impulse\n")
dump_queue()
svwrite(");\n")
dump_queue()
svwrite("\n")
dump_queue()
svwrite("// Get vectors from centers of OBBS to contact point\n")
dump_queue()
r1 = Contact.location - obb1.pos
r2 = Contact.location - obb2.pos
svwrite("\n")
dump_queue()
svwrite("/* Steps:\n")
dump_queue()
svwrite("    1. Get relative velocity\n")
dump_queue()
svwrite("    2. Use to calculate separating velocity\n")
dump_queue()
svwrite("*/\n")
dump_queue()
vs = Fixed(5, 19, "vs")
vs.declare()
totalIMass = Fixed(2, 8, "totalIMass")
totalIMass.declare()
svwrite("\n")
dump_queue()
svwrite("// Invert total inverse mass because we gotta divide by it\n")
dump_queue()
inv_totalIMass = inverse(totalIMass)
svwrite("\n")
dump_queue()
double_nudge = Vec2(8, 16, "double_nudge")
double_nudge.declare()
svwrite("\n")
dump_queue()
r1Cross = Fixed(8, 14, "r1Cross")
r2Cross = Fixed(8, 14, "r2Cross")
r1Cross.declare()
r2Cross.declare()
svwrite("\n")
dump_queue()
v_rel = Vec2(5, 19, "v_rel")
v_rel.declare()
svwrite("\n")
dump_queue()
begin_comb()
svwrite("\n")
dump_queue()
svwrite("// Get vector omega x r1 and omega x r2\n")
dump_queue()
vw1 = ExpressionVec2(-r1[1], r1[0]) * obb1.omega
vw2 = ExpressionVec2(-r2[1], r2[0]) * obb2.omega
svwrite("\n")
dump_queue()
svwrite("// Get relative velocity\n")
dump_queue()
v_rel.assign((obb1.vel - obb2.vel) + (vw1 - vw2))
svwrite("\n")
dump_queue()
svwrite("// Get separating velocity\n")
dump_queue()
vs.assign(v_rel.Dot(Contact.normal))
svwrite("\n")
dump_queue()
svwrite("// Get total inverse mass/inertia\n")
dump_queue()
r1Cross.assign(r1.Cross(Contact.normal))
r2Cross.assign(r2.Cross(Contact.normal))
r1CrossInertia = r1Cross * obb1.inv_inertia
r2CrossInertia = r2Cross * obb2.inv_inertia
print(r1CrossInertia.integer_bits, r1CrossInertia.precision)
svwrite("\n")
dump_queue()
totalIMass.assign((obb1.inv_mass + obb2.inv_mass) + (r1Cross * r1CrossInertia) + (r2Cross * r2CrossInertia))
svwrite("\n")
dump_queue()
svwrite("// Calculate impulse vector\n")
dump_queue()
impulse_magnitude = (vs * (-(1 + RESTITUTION)) * inv_totalIMass)
impulse1.impulse.assign(Contact.normal * impulse_magnitude)
impulse2.impulse.assign(-impulse1.impulse)
svwrite("\n")
dump_queue()
svwrite("// Calculate rotational impulse for both boxes\n")
dump_queue()
impulse1.rotational_impulse.assign(impulse_magnitude * r1CrossInertia)
impulse2.rotational_impulse.assign(-(impulse_magnitude * r2CrossInertia))
svwrite("\n")
dump_queue()
svwrite("//// Getting nudge vector\n")
dump_queue()
double_nudge.assign(Contact.normal * Contact.penetration)
svwrite("")
svpy.inline_state = True
svwrite(impulse1.nudge.x)
svpy.inline_state = False
svwrite(" = ")
svpy.inline_state = True
svwrite(double_nudge.x)
svpy.inline_state = False
svwrite(" >>> 1;\n")
dump_queue()
svwrite("")
svpy.inline_state = True
svwrite(impulse1.nudge.y)
svpy.inline_state = False
svwrite(" = ")
svpy.inline_state = True
svwrite(double_nudge.y)
svpy.inline_state = False
svwrite(" >>> 1;\n")
dump_queue()
impulse2.nudge.assign(-impulse1.nudge)
svwrite("\n")
dump_queue()
end_comb()
svwrite("\n")
dump_queue()
svwrite("// If separating velocity is positive, don't apply the impulse\n")
dump_queue()
svwrite("assign ignore_impulse = ~vs[23];\n")
dump_queue()
svwrite("\n")
dump_queue()
svwrite("endmodule")
dump_queue()
svpy.writefile.close()