import svpy
from svpy import *
svpy.writefile = open("../lab6_2_provided/design_source/inverter.sv", 'w')
import svmath
import utils
svwrite("// inverse.sv\n")
dump_queue()
svwrite("//  - Uses a lookup table to compute the multiplicative inverse \n")
dump_queue()
svwrite("//  - Note: This only works for unsigned values because that's all we need for this project\n")
dump_queue()
svwrite("\n")
dump_queue()
from svmath import *
svwrite("\n")
dump_queue()
x = Fixed(10, 0, "x")
x_inverse = Fixed(1, 15, "x_inverse")
svwrite("\n")
dump_queue()
svwrite("module inverter\n")
dump_queue()
svwrite("(\n")
dump_queue()
svwrite("    input logic [9 : 0] x,\n")
dump_queue()
svwrite("    output logic [15 : 0] x_inverse\n")
dump_queue()
svwrite(");\n")
dump_queue()
svwrite("\n")
dump_queue()
svwrite("parameter ADDR_WIDTH = 10;\n")
dump_queue()
svwrite("parameter DATA_WIDTH = 16;\n")
dump_queue()
svwrite("logic [9:0] addr_reg;\n")
dump_queue()
svwrite("\n")
dump_queue()
svwrite("parameter [0:2**ADDR_WIDTH-1][DATA_WIDTH-1:0] ROM = {\n")
dump_queue()
svwrite("10'b0,\n")
dump_queue()
for i in range(1, 2**10):
    line = svmath.to_bits(1 / i, 1, 15, signed=False)
    if i != 2**10 - 1:
        line += ","
    svwrite(line, "\n")
svwrite("};\n")
dump_queue()
svwrite("\n")
dump_queue()
svwrite("assign x_inverse[DATA_WIDTH-1:0] = ROM[x][DATA_WIDTH-1:0];\n")
dump_queue()
svwrite("\n")
dump_queue()
svwrite("endmodule")
dump_queue()
svpy.writefile.close()